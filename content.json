[{"title":"blogå¤šè¯­è¨€è®¡åˆ’","path":"2022/10/17/blogå¤šè¯­è¨€è®¡åˆ’/","text":"ç°åœ¨æˆ‘çš„blogæ”¯æ´ä¸¤ä¸ªè¯­è¨€äº†ï¼ ï¼ ï¼ ï¼ ï¼ç›®å‰æœ‰ä¸¤ä¸ªå‰¯æœ¬ï¼Œæ”¯æ´ã€Œç®€ä½“å­—ã€ä¸ã€Œç¹ä½“å­—ã€ï¼Œé¢„è®¡ä¹‹åä¼šåŠ å…¥ã€ŒEnglishã€ï¼Œä¸‹é¢ä¼šç»™å‡ºè·³è½¬è¿ç»“ï¼ ç¹ä½“å­—ç®€ä½“å­—"},{"title":"ä½¿ç”¨Cloudflare Workeræ¥è¿›è¡ŒFirebaseä»£ç†","path":"2022/07/19/ä½¿ç”¨Cloudflare Workeræ¥è¿›è¡ŒFirebaseä»£ç†/","text":"ä½¿ç”¨Cloudflare Workerä»£ç†Firebaseé“¾æ¥ æœ€è¿‘æœ‰ä¸€ä¸ªä¸“æ¡ˆä½¿ç”¨Firebaseæ¥å­˜å‚¨ç”¨æˆ·ä»¬ä¸Šä¼ çš„å›¾ç‰‡æ¡£ï¼Œä½†æ˜¯Firebaseåœ¨ä¸­å›½å¤§é™†æ˜¯è¢«é˜²ç«é•¿åŸé˜»æŒ¡çš„ï¼Œå› æ­¤ä¸­å›½å¤§é™†çš„ä½¿ç”¨è€…æ— æ³•æŸ¥çœ‹å›¾ç‰‡ äºæ˜¯ï¼Œå°±æœ‰äº†æœ¬ç¯‡Blog è¿™ç¯‡Blogä¼šæ•™ä½ å¦‚ä½•ä½¿ç”¨Cloudflareæä¾›çš„å…è´¹çš„WorkeræœåŠ¡ï¼Œæ¥å»ºç«‹ä¸€ä¸ªProxyï¼Œç„¶åæ— è®ºæ¥è‡ªå“ªä¸ªåœ°æ–¹çš„äººéƒ½å¯ä»¥é€šè¿‡ä»£ç†çš„è¿ç»“æ­£å¸¸è®¿é—®Firebaseçš„æ¡£æ¡ˆã€‚ é¡ºå¸¦ä¸€æï¼š æ–‡ç« æœ«å°¾æœ‰åœ¨ä¸‹æ­å»ºå¥½çš„ä»£ç†è¿ç»“ï¼Œå„ä½ä¹Ÿå¯ä»¥ä½¿ç”¨åœ¨ä¸‹çš„Proxyï¼Œå…å»è‡ªå·±æ­å»ºçš„éº»çƒ¦ï¼ ï¼ é¦–å…ˆéœ€è¦ä¸€ä¸ªCloudflareå¸æˆ·ï¼Œå¦‚æœæ²¡æœ‰å¯ä»¥å»æ³¨å†Œä¸€ä¸ª -&gt; 0ã€ Cloudflareå®˜æ–¹ç½‘ç«™çš„è¿ç»“ -&gt; 1ã€ç™»å…¥åï¼Œè¿›å…¥ä½ çš„æ§åˆ¶å° -&gt; 2ã€é€‰æ‹©å·¦è¾¹çš„Worker -&gt; 3ã€å†ç‚¹é€‰ã€Œå»ºç«‹æœåŠ¡ã€æ³¨æ„è¿™é‡Œé€‰æ‹©ã€ŒHttpå¤„ç†å¸¸å¼ã€å³å¯ -&gt; 4ã€ç‚¹é€‰ã€Œå¿«é€Ÿç¼–è¾‘ã€ï¼æˆ‘ä»¬ä¸ä½¿ç”¨Cliè¿›è¡Œç¼–è¾‘ï¼Œå› ä¸ºè¿™å±äºç®€å•çš„ä»»åŠ¡ï¼Œä½¿ç”¨Cliåè€Œæµªè´¹æ—¶é—´ -&gt; 5ã€å¼€å§‹ç¼–å†™ä»£ç†æœåŠ¡ï¼ç®€å•ä»‹ç»ä¸€ä¸‹ä»€ä¹ˆæ˜¯Cloudflare Worker***Cloudflare Workerå…¶å®æ˜¯Cloudflareæä¾›çš„ä¸€ä¸ªæå…¶è½»é‡çš„äº‘ç«¯ä¼ºæœå™¨ï¼Œå®ƒçš„åŸºæœ¬åŠŸèƒ½å°±æ˜¯èƒ½å¤Ÿæ¥å—è¯·æ±‚ï¼Œè¿›è¡Œå¤„ç†åè¿”å›æ•°æ®&#x2F;ç½‘é¡µç­‰ç­‰èµ„æºã€‚ ******Cloudflare Workeræ˜¯å…è´¹ä½¿ç”¨çš„ï¼ˆå…è´¹è®¡ç”»ï¼‰ï¼Œå¹¶ä¸”å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå…è´¹è®¡ç”»å°±å·²ç»èƒ½å¤Ÿæ»¡è¶³æˆ‘ä»¬çš„å¤§éƒ¨åˆ†éœ€æ±‚ã€‚ *** -&gt; 6ã€èƒ½å¤Ÿé€è¿‡Workerè®¿é—®è¢«å°é”çš„Firebaseçš„åŸç†***ä¸Šæ–‡æåˆ°ï¼ŒFirebaseåœ¨ä¸­å›½å¤§é™†è¢«å°é”ã€‚ä½†æ˜¯Workerå¹¶æœªè¢«å°é”ï¼Œå¹¶ä¸”Workerèƒ½å¤Ÿæ­£å¸¸è®¿é—®Firebaseï¼Œå› æ­¤å°±å¯ä»¥å®ç°ä»¥ä¸‹é€»è¾‘ã€‚ ***ä½¿ç”¨è€…é€è¿‡å‘Workerå‘èµ·è¯·æ±‚ï¼ˆè¯·æ±‚ï¼‰-&gt; Workeræ¥å—è¯·æ±‚ï¼Œå¹¶è¯»å–è¯·æ±‚å†…éœ€è¦ä»£ç†è®¿é—®çš„åœ°å€ -&gt; Workerè®¿é—®åœ°å€å¾—åˆ°èµ„æº -&gt; è¿”å›ç»™æ¥æº -&gt; 7ã€æºä»£ç åŠéƒ¨åˆ†***ä»£ç æºè‡ªç½‘è·¯ï¼Œå¯¹äºæœ¬ä¸“æ¡ˆçš„éœ€æ±‚ï¼Œåœ¨ä¸‹è¿›è¡Œäº†æ›´æ”¹é€‚é…ã€‚ *** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416addEventListener(&quot;fetch&quot;, event =&gt; &#123; event.passThroughOnException(); if (event.request.method === &#x27;GET&#x27;) &#123; const url = new URL(event.request.url); const accept = event.request.headers.get(&#x27;Accept&#x27;); if (url.pathname.startsWith(&#x27;/firebasestorage.googleapis.com/&#x27;)) &#123; // å°‡è«‹æ±‚è½‰ç™¼çµ¦åŸä¼ºæœå™¨ event.respondWith(proxyRequest(&#x27;https:/&#x27; + url.pathname + url.search, event.request)); &#125; else if (accept &amp;&amp; (accept.indexOf(&#x27;text/html&#x27;) &gt;= 0 || accept.indexOf(&#x27;text/css&#x27;) &gt;= 0)) &#123; if (url.pathname.startsWith(&#x27;/firebasestorage.googleapis.com/&#x27;)) &#123; event.respondWith(proxyStylesheet(&#x27;https:/&#x27; + url.pathname + url.search, event.request)); &#125; else &#123; event.respondWith(processRequest(event.request, event)); &#125; &#125; &#125;&#125;);const VALID_CHARSETS = [&#x27;utf-8&#x27;, &#x27;utf8&#x27;, &#x27;iso-8859-1&#x27;, &#x27;us-ascii&#x27;];async function proxyRequest(url, request) &#123; let init = &#123; method: request.method, headers: &#123;&#125; &#125;; // åªå…è¨±é€™äº›Headers const proxyHeaders = [&quot;Accept&quot;, &quot;Accept-Encoding&quot;, &quot;Accept-Language&quot;, &quot;Referer&quot;, &quot;User-Agent&quot;]; for (let name of proxyHeaders) &#123; let value = request.headers.get(name); if (value) &#123; init.headers[name] = value; &#125; &#125; // ä½¿ç”¨æºipæ–°å»º X-Forwarded-For è«‹æ±‚é ­ const clientAddr = request.headers.get(&#x27;cf-connecting-ip&#x27;); if (clientAddr) &#123; init.headers[&#x27;X-Forwarded-For&#x27;] = clientAddr; &#125; const response = await fetch(url, init); if (response) &#123; const responseHeaders = [&quot;Content-Type&quot;, &quot;Cache-Control&quot;, &quot;Expires&quot;, &quot;Accept-Ranges&quot;, &quot;Date&quot;, &quot;Last-Modified&quot;, &quot;ETag&quot;]; let responseInit = &#123;status: response.status, statusText: response.statusText, headers: &#123;&#125;&#125;; for (let name of responseHeaders) &#123; let value = response.headers.get(name); if (value) &#123; responseInit.headers[name] = value; &#125; &#125; responseInit.headers[&#x27;X-Content-Type-Options&#x27;] = &quot;nosniff&quot;; const newResponse = new Response(response.body, responseInit); return newResponse; &#125; return response;&#125;async function proxyStylesheet(url, request) &#123; let css = await fetchCSS(url, request) if (css) &#123; const responseInit = &#123;headers: &#123; &quot;Content-Type&quot;: &quot;text/css; charset=utf-8&quot;, &quot;Cache-Control&quot;: &quot;private, max-age=86400, stale-while-revalidate=604800&quot; &#125;&#125;; const newResponse = new Response(css, responseInit); return newResponse; &#125; else &#123; return proxyRequest(url, request); &#125;&#125;async function processRequest(request, event) &#123; const response = await fetch(request); if (response &amp;&amp; response.status === 200) &#123; const contentType = response.headers.get(&quot;content-type&quot;); if (contentType &amp;&amp; contentType.indexOf(&quot;text/html&quot;) !== -1) &#123; return await processHtmlResponse(response, event.request, event); &#125; else if (contentType &amp;&amp; contentType.indexOf(&quot;text/css&quot;) !== -1) &#123; return await processStylesheetResponse(response, event.request, event); &#125; &#125; return response;&#125;async function processHtmlResponse(response, request, event) &#123; const contentType = response.headers.get(&quot;content-type&quot;); const charsetRegex = /charset\\s*=\\s*([^\\s;]+)/mgi; const match = charsetRegex.exec(contentType); if (match !== null) &#123; let charset = match[1].toLowerCase(); if (!VALID_CHARSETS.includes(charset)) &#123; return response; &#125; &#125; let embedStylesheet = true; let csp = response.headers.get(&quot;Content-Security-Policy&quot;); if (csp) &#123; let ok = false; let cspRule = null; const styleRegex = /style-src[^;]*/gmi; let match = styleRegex.exec(csp); if (match !== null) &#123; cspRule = match[0]; &#125; else &#123; const defaultRegex = /default-src[^;]*/gmi; let match = defaultRegex.exec(csp); if (match !== null) &#123; cspRule = match[0]; &#125; &#125; if (cspRule !== null) &#123; if (cspRule.indexOf(&quot;&#x27;unsafe-inline&#x27;&quot;) &gt;= 0) &#123; ok = true; embedStylesheet = true; &#125; else if (cspRule.indexOf(&quot;&#x27;self&#x27;&quot;) &gt;= 0) &#123; ok = true; embedStylesheet = false; &#125; &#125; if (!ok) &#123; return response; &#125; &#125; const &#123; readable, writable &#125; = new TransformStream(); const newResponse = new Response(readable, response); modifyHtmlStream(response.body, writable, request, event, embedStylesheet); return newResponse;&#125;async function processStylesheetResponse(response, request, event) &#123; let body = response.body; try &#123; body = await response.text(); const fontCSSRegex = /@import\\s*(url\\s*)?[\\(&#x27;&quot;\\s]+((https?:)?\\/\\/fonts.googleapis.com\\/css[^&#x27;&quot;\\)]+)[\\s&#x27;&quot;\\)]+\\s*;/mgi; let match = fontCSSRegex.exec(body); while (match !== null) &#123; const matchString = match[0]; const fontCSS = await fetchCSS(match[2], request, event); if (fontCSS.length) &#123; body = body.split(matchString).join(fontCSS); fontCSSRegex.lastIndex -= matchString.length - fontCSS.length; &#125; match = fontCSSRegex.exec(body); &#125; &#125; catch (e) &#123;&#125; const newResponse = new Response(body, response); return newResponse;&#125;function chunkContainsInvalidCharset(chunk) &#123; let invalid = false; const charsetRegex = /&lt;\\s*meta[^&gt;]+charset\\s*=\\s*[&#x27;&quot;]([^&#x27;&quot;]*)[&#x27;&quot;][^&gt;]*&gt;/mgi; const charsetMatch = charsetRegex.exec(chunk); if (charsetMatch) &#123; const docCharset = charsetMatch[1].toLowerCase(); if (!VALID_CHARSETS.includes(docCharset)) &#123; invalid = true; &#125; &#125; const contentTypeRegex = /&lt;\\s*meta[^&gt;]+http-equiv\\s*=\\s*[&#x27;&quot;]\\s*content-type[^&gt;]*&gt;/mgi; const contentTypeMatch = contentTypeRegex.exec(chunk); if (contentTypeMatch) &#123; const metaTag = contentTypeMatch[0]; const metaRegex = /charset\\s*=\\s*([^\\s&quot;]*)/mgi; const metaMatch = metaRegex.exec(metaTag); if (metaMatch) &#123; const charset = metaMatch[1].toLowerCase(); if (!VALID_CHARSETS.includes(charset)) &#123; invalid = true; &#125; &#125; &#125; return invalid;&#125;async function modifyHtmlStream(readable, writable, request, event, embedStylesheet) &#123; const reader = readable.getReader(); const writer = writable.getWriter(); const encoder = new TextEncoder(); let decoder = new TextDecoder(&quot;utf-8&quot;, &#123;fatal: true&#125;); let firstChunk = true; let unsupportedCharset = false; let partial = &#x27;&#x27;; let content = &#x27;&#x27;; try &#123; for(;;) &#123; const &#123; done, value &#125; = await reader.read(); if (done) &#123; if (partial.length) &#123; partial = await modifyHtmlChunk(partial, request, event, embedStylesheet); await writer.write(encoder.encode(partial)); partial = &#x27;&#x27;; &#125; break; &#125; let chunk = null; if (unsupportedCharset) &#123; await writer.write(value); continue; &#125; else &#123; try &#123; chunk = decoder.decode(value, &#123;stream:true&#125;); &#125; catch (e) &#123; unsupportedCharset = true; if (partial.length) &#123; await writer.write(encoder.encode(partial)); partial = &#x27;&#x27;; &#125; await writer.write(value); continue; &#125; &#125; try &#123; if (firstChunk) &#123; firstChunk = false; if (chunkContainsInvalidCharset(chunk)) &#123; // switch to passthrough unsupportedCharset = true; if (partial.length) &#123; await writer.write(encoder.encode(partial)); partial = &#x27;&#x27;; &#125; await writer.write(value); continue; &#125; &#125; content = partial + chunk; partial = &#x27;&#x27;; const linkPos = content.lastIndexOf(&#x27;&lt;link&#x27;); if (linkPos &gt;= 0) &#123; const linkClose = content.indexOf(&#x27;/&gt;&#x27;, linkPos); if (linkClose === -1) &#123; partial = content.slice(linkPos); content = content.slice(0, linkPos); &#125; &#125; if (content.length) &#123; content = await modifyHtmlChunk(content, request, event, embedStylesheet); &#125; &#125; catch (e) &#123;&#125; if (content.length) &#123; await writer.write(encoder.encode(content)); content = &#x27;&#x27;; &#125; &#125; &#125; catch(e) &#123;&#125; try &#123; await writer.close(); &#125; catch(e) &#123;&#125;&#125;async function modifyHtmlChunk(content, request, event, embedStylesheet) &#123; const fontCSSRegex = /&lt;link\\s+[^&gt;]*href\\s*=\\s*[&#x27;&quot;]((https?:)?\\/\\/fonts.googleapis.com\\/css[^&#x27;&quot;]+)[^&gt;]*&gt;/mgi; let match = fontCSSRegex.exec(content); while (match !== null) &#123; const matchString = match[0]; if (matchString.indexOf(&#x27;stylesheet&#x27;) &gt;= 0) &#123; if (embedStylesheet) &#123; const fontCSS = await fetchCSS(match[1], request, event); if (fontCSS.length) &#123; // See if there is a media type on the link tag let mediaStr = &#x27;&#x27;; const mediaMatch = matchString.match(/media\\s*=\\s*[&#x27;&quot;][^&#x27;&quot;]*[&#x27;&quot;]/mig); if (mediaMatch) &#123; mediaStr = &#x27; &#x27; + mediaMatch[0]; &#125; // Replace the actual css let cssString = &quot;&lt;style&quot; + mediaStr + &quot;&gt;\\n&quot;; cssString += fontCSS; cssString += &quot;\\n&lt;/style&gt;\\n&quot;; content = content.split(matchString).join(cssString); fontCSSRegex.lastIndex -= matchString.length - cssString.length; &#125; &#125; else &#123; // Rewrite the URL to proxy it through the origin let originalUrl = match[1]; let startPos = originalUrl.indexOf(&#x27;/fonts.googleapis.com&#x27;); let newUrl = originalUrl.substr(startPos); let newString = matchString.split(originalUrl).join(newUrl); content = content.split(matchString).join(newString); fontCSSRegex.lastIndex -= matchString.length - newString.length; &#125; match = fontCSSRegex.exec(content); &#125; &#125; return content;&#125;var FONT_CACHE = &#123;&#125;;async function fetchCSS(url, request) &#123; let fontCSS = &quot;&quot;; if (url.startsWith(&#x27;/&#x27;)) url = &#x27;https:&#x27; + url; const userAgent = request.headers.get(&#x27;user-agent&#x27;); const clientAddr = request.headers.get(&#x27;cf-connecting-ip&#x27;); const browser = getCacheKey(userAgent); const cacheKey = browser ? url + &#x27;&amp;&#x27; + browser : url; const cacheKeyRequest = new Request(cacheKey); let cache = null; let foundInCache = false; if (cacheKey in FONT_CACHE) &#123; // hit in the memory cache fontCSS = FONT_CACHE[cacheKey]; foundInCache = true; &#125; else &#123; // Try pulling it from the cache API (wrap it in case it&#x27;s not implemented) try &#123; cache = caches.default; let response = await cache.match(cacheKeyRequest); if (response) &#123; fontCSS = await response.text(); foundInCache = true; &#125; &#125; catch(e) &#123; // Ignore the exception &#125; &#125; if (!foundInCache) &#123; let headers = &#123;&#x27;Referer&#x27;: request.url&#125;; if (browser) &#123; headers[&#x27;User-Agent&#x27;] = userAgent; &#125; else &#123; headers[&#x27;User-Agent&#x27;] = &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&quot;; &#125; if (clientAddr) &#123; headers[&#x27;X-Forwarded-For&#x27;] = clientAddr; &#125; try &#123; const response = await fetch(url, &#123;headers: headers&#125;); if (response &amp;&amp; response.status === 200) &#123; fontCSS = await response.text(); fontCSS = fontCSS.replace(/(https?:)?\\/\\/fonts\\.gstatic\\.com\\//mgi, &#x27;/fonts.gstatic.com/&#x27;); FONT_CACHE[cacheKey] = fontCSS; try &#123; if (cache) &#123; const cacheResponse = new Response(fontCSS, &#123;ttl: 86400&#125;); event.waitUntil(cache.put(cacheKeyRequest, cacheResponse)); &#125; &#125; catch(e) &#123;&#125; &#125; &#125; catch(e) &#123;&#125; &#125; return fontCSS;&#125;function getCacheKey(userAgent) &#123; let os = &#x27;&#x27;; const osRegex = /^[^(]*\\(\\s*(\\w+)/mgi; let match = osRegex.exec(userAgent); if (match) &#123; os = match[1]; &#125; let mobile = &#x27;&#x27;; if (userAgent.match(/Mobile/mgi)) &#123; mobile = &#x27;Mobile&#x27;; &#125; const edgeRegex = /\\s+Edge\\/(\\d+)/mgi; match = edgeRegex.exec(userAgent); if (match) &#123; return &#x27;Edge&#x27; + match[1] + os + mobile; &#125; const chromeRegex = /\\s+Chrome\\/(\\d+)/mgi; match = chromeRegex.exec(userAgent); if (match) &#123; return &#x27;Chrome&#x27; + match[1] + os + mobile; &#125; const webkitRegex = /\\s+AppleWebKit\\/(\\d+)/mgi; match = webkitRegex.exec(userAgent.match); if (match) &#123; return &#x27;WebKit&#x27; + match[1] + os + mobile; &#125; const firefoxRegex = /\\s+Firefox\\/(\\d+)/mgi; match = firefoxRegex.exec(userAgent); if (match) &#123; return &#x27;Firefox&#x27; + match[1] + os + mobile; &#125; return null;&#125; ç°åœ¨å³å¯ä½¿ç”¨ï¼Œæ–¹æ³•æ˜¯ä¾‹å¦‚æˆ‘è¦è®¿é—®https://firebasestorage.googleapis.com/v0/b/mikuproject-e9478.appspot.com/o/mikuproject-files%2F404.png?alt=media&amp;token=40bb05e9-d925-48a4-b4f5-800a28153b92ç°åœ¨åªè¦åœ¨è¿ç»“çš„https:&#x2F;&#x2F;åï¼ŒåŠ ä¸Šä½ çš„Workerçš„åŸŸåå³å¯æ›´æ”¹åçš„è¿ç»“å˜ä¸ºhttps://objectproxy.1205.moe/firebasestorage.googleapis.com/v0/b/mikuproject-e9478.appspot.com/o/mikuproject-files%2F404.png?alt=media&amp;token=40bb05e9-d925-48a4-b4f5-800a28153b92 ç°æˆçš„ä½œä¸š Worker: https://objectproxy.1205.moe/"},{"title":"åœ¨Vueç¨‹å¼ä¸­ä½¿ç”¨Electronæ¡†æ¶","path":"2022/05/01/åœ¨Vueç¨‹åºä¸­ä½¿ç”¨Electronæ¡†æ¶/","text":"åœ¨Vueç¨‹å¼ä¸­ä½¿ç”¨Electronæ¡†æ¶ ä»Šå¤©ç§ƒç„¶é‡åˆ°ä¸€ä¸ªéœ€æ±‚ï¼Œå³æ„å»ºè·¨å¹³å°çš„åº”ç”¨ç¨‹å¼ï¼Œé‚£ä¹ˆå¯¹äºæˆ‘ä¸€ä¸ªå…¨æ ˆå¼€å‘æ¥è¯´ï¼Œä½¿ç”¨Electronå°±æ˜¯æœ€å¥½çš„é€‰æ‹©äº†ã€‚ äº†è§£ä¸€ä¸‹ï¼Œä»€ä¹ˆæ˜¯Electron ***Electron æ˜¯ä¸€ä¸ªå¼€æº JavaScript æ¡†æ¶ï¼Œç”¨äºä½¿ç”¨ Web æŠ€æœ¯ï¼ˆHTMLã€CSS å’Œ JavaScriptï¼‰æ„å»ºè·¨å¹³å°çš„åº”ç”¨ç¨‹åºã€‚è¿™æ„å‘³ç€å¦‚æœæ‚¨äº‹å…ˆç†Ÿæ‚‰ä½¿ç”¨è¿™äº›æŠ€æœ¯ï¼Œæ‚¨å¯ä»¥ç›´æ¥ä½¿ç”¨åŸå…ˆçš„æºä»£ç æ„å»ºæˆWindowsã€Linux å’Œ macOS çš„æ¡Œé¢åº”ç”¨ç¨‹åºã€‚ *** ***èƒŒåï¼ŒElectron å°† Chromium å¼•æ“ä¸ Node.js è¿è¡Œæ—¶ç¯å¢ƒç›¸ç»“åˆï¼Œæ¥è¿è¡Œæ‚¨çš„ç¨‹å¼ã€‚è€Œä¸”ï¼Œå·²æœ‰è®¸å¤šçŸ¥åä»¥Electronæ„å»ºçš„ç¨‹å¼ï¼Œæ¯”å¦‚ Slackã€VS Code å’Œ WhatsApp Desktopã€‚ *** é‚£ä¹ˆï¼Œä¾ç…§ä¸æˆ‘çš„æœ¬æ¬¡å®è·µï¼Œæ¥å‘Šè¯‰å„ä½å°çŒ«å’ªå¦‚ä½•ä½¿ç”¨Electronæ„å»ºåŸºäºVueçš„App -&gt; 0ã€æœ€åŸºæœ¬çš„å®‰è£…npmï¼ˆä¸éœ€è¦è®²äº†å§wwwï¼‰ -&gt; 1ã€å®‰è£…vue cli 1npm install -g @vue/cli å…¨å±€å®‰è£…vue cli -&gt; 2ã€ä½¿ç”¨vue createæŒ‡ä»¤æ–°å»ºä¸€ä¸ªé¡¹ç›® 1vue create your-project æ–°å»ºä¸€ä¸ªåå­—æ˜¯your-projectçš„é¡¹ç›® -&gt; 3ã€ä½¿ç”¨vue addå‘½ä»¤æ–°å¢ä¸€ä¸ªæ’ä»¶ 1vue add electron-builder å°†åå­—æ˜¯electron-builderçš„æ’ä»¶åŠ å…¥ä½ çš„é¡¹ç›®!æ³¨æ„ï¼Œæ‚¨éœ€è¦cdå…¥æ‚¨çš„é¡¹ç›®ç›®å½•åæ–¹å¯æ‰§è¡Œè¿™æ¡å‘½ä»¤ -&gt; 4ã€è¿è¡Œç¨‹å¼ 1npm run electron:serve å¼€å¯åº”ç”¨ç¨‹å¼!æ³¨æ„ï¼Œæ‚¨éœ€è¦cdå…¥æ‚¨çš„é¡¹ç›®ç›®å½•åæ–¹å¯æ‰§è¡Œè¿™æ¡å‘½ä»¤!æ³¨æ„ï¼Œè‹¥æœ‰é”™è¯¯æ‚¨å¯ä»¥å°è¯•æ‰§è¡Œ npm i ç°åœ¨å³å¯è¿›è¡Œå¼€å‘ å¦‚ä½•æ‰“åŒ…æˆå¯ä»¥åˆ†å‘çš„åº”ç”¨ç¨‹å¼å‘¢ï¼Ÿ å…¶å®å¾ˆç®€å•ï¼Œåœ¨éœ€è¦æ‰“åŒ…æˆå¯¹åº”åº”ç”¨ç¨‹å¼çš„å¹³å°å†…æ‰§è¡Œï¼š 1npm run electron:build ç°åœ¨å³å¯å®Œæˆè¿™ä¸ªåº”ç”¨çš„å¼€å‘ï¼"},{"title":"è½¬ä¹‰","path":"2022/04/13/è½¬ä¹‰/","text":"è½¬ä¹‰ ç”±äºå­¦ä¹ JavaScriptæ—¶æ˜¯ä¾ç…§å®é™…æ¡ˆä¾‹æ¥å­¦ä¹ çš„ï¼Œå› æ­¤é—æ¼äº†æŸäº›å°‘ç”¨åˆ°çš„æ–¹é¢ã€‚ æœ€è¿‘åœ¨å®ç°ä¸€ä¸ªéœ€æ±‚æ—¶ï¼Œå‘ç°è½¬ä¹‰ç¬¦çœŸçš„è¶…å¥½ç”¨ï¼ ï¼ä¸‹é¢æ˜¯éœ€æ±‚è¯¦æƒ…ï¼š -&gt;éœ€è¦å‘ä¼ºæœå™¨å†…å­˜å…¥htmlç‰‡æ®µï¼Œå¹¶ä¸”è¿™äº›htmlç‰‡æ®µæœ‰è¡Œå†…æ ·å¼ï¼Œå¦‚ä¸‹å›¾ 12345&#123; &quot;title&quot;:&quot;SPRING&quot;, &quot;honor&quot;:&quot;&lt;span style=&#x27;color: blue;&#x27;&gt;SPRING&lt;/span&gt;&quot;, &quot;description&quot;:&quot;ä»£è¡¨æ‚¨åŠ å…¥äº†SPRINGè®¡ç”»&quot;&#125; å‘ç°é—®é¢˜ğŸ¤”ï¼šåœ¨è¿™é‡Œå•å¼•å·ï¼ŒåŒå¼•å·éƒ½ç”¨ä¸Šäº†ï¼Œé‚£ä¹ˆè¦å¦‚ä½•æ‰èƒ½åœ¨SQLè¯­å¥å†…æ‹¼ä¸Šè¿™æ®µå­—ç¬¦ä¸²å‘¢ï¼Ÿ è¶…çº§é‡è¦ï¼ ï¼ ï¼ -&gt; SQLè¯­å¥éœ€è¦è¢«ä¸€å¯¹å¼•å·æ‹¬èµ·æ¥ã€‚ æœ‰çš„å°çŒ«å’ªå¯èƒ½å°±ä¼šè¯´äº†ï¼Œç”¨æ¨¡æ¿å­—ç¬¦ä¸²(``)ä¸å°±å¯ä»¥äº†å—ï¼Ÿ å…¶å®æ˜¯ä¸è¡Œçš„ï¼Œè¯·çœ‹è¿™å¼ å›¾ è¿™é‡Œä½¿ç”¨å•å¼•å·ã€åŒå¼•å·éƒ½ä¼šæŠ¥é”™ -&gt; æ‰€ä»¥è¿™é‡Œçš„è§£å†³æ–¹æ¡ˆå°±æ˜¯ï¼šè½¬ä¹‰ç¬¦å·ç»™å‡ºæ­£ç¡®çš„SQLè¯­å¥ 1UPDATE items SET itemValue =&#x27;&#123;&quot;title&quot;:&quot;SPRING&quot;,&quot;honor&quot;:&quot;&lt;span style=\\&#x27;color: blue;\\&#x27;&gt;SPRING&lt;/span&gt;&quot;,&quot;description&quot;:&quot;ä»£è¡¨æ‚¨åŠ å…¥äº†SPRINGè®¡ç”»&quot;&#125;&#x27; WHERE itemKey=&quot;UID1*ActivatedHonor&quot; æˆåŠŸï¼"},{"title":"ç”¨csså®ç°ç½‘é¡µé«˜æ–¯æ¨¡ç³Šç‰¹æ•ˆ","path":"2022/02/21/ç”¨csså®ç°ç½‘é¡µé«˜æ–¯æ¨¡ç³ŠèƒŒæ™¯/","text":"ç”¨csså®ç°ç½‘é¡µé«˜æ–¯æ¨¡ç³Šç‰¹æ•ˆ Attention: è¿™ç¯‡æ–‡ç« æ¢è®¨çš„æ˜¯å¦‚ä½•å®ç°èƒŒæ™¯é«˜æ–¯æ¨¡ç³Šï¼Œè€Œä¸æ˜¯æ•´ä¸ªè§†å›¾é«˜æ–¯æ¨¡ç³Šï¼ ï¼ ï¼ å¤§æ¦‚æ•ˆæœæ˜¯è¿™æ ·ï¼š æ²¡æœ‰é«˜æ–¯æ¨¡ç³Š ä½¿ç”¨é«˜æ–¯æ¨¡ç³Šæ•ˆæœ æ€ä¹ˆæ ·ï¼Ÿ ï¼Ÿæ˜¯ä¸æ˜¯æ„Ÿè§‰å¥½æ¼‚äº®çš„æ•ˆæœï¼Œé‚£ä¹ˆå¦‚ä½•å®ç°å‘¢(Â¯ï¸¶Â¯) å…ˆæ¥çœ‹çœ‹DOMç»“æ„å…¶å®æœ‰ä¸¤ç§æ–¹æ³•ï¼Œè¿™æ˜¯æ–¹æ³•ä¸€ï¼Œç›¸å®¹æ€§è¾ƒå¥½ï¼ -&gt; å¤–å±‚æœ‰ä¸€ä¸ª id&#x3D;animeDetails çš„Divæ ‡ç­¾ï¼Œç”¨äºæ’‘èµ·æ•´ä¸ªé¡µé¢çš„é«˜åº¦123#animeDetails &#123; height: 100%;&#125; -&gt; å†…å±‚ä½¿ç”¨äº† class&#x3D;animeDetails_mask çš„ä¸€ä¸ªDivæ ‡ç­¾ç”¨äºæ”¾å…¥è¦å±•ç¤ºçš„å†…å®¹ï¼Œä¾‹å¦‚ç°åœ¨æˆ‘æ”¾å…¥çš„æ˜¯contentsè¿™å‡ ä¸ªå­—123456.animeDetails_mask &#123; position: relative; /* è®©è¿™ä¸ªdivèƒ½å¤Ÿå æ»¡ç”»é¢ */ height: 100%; /* æ’‘èµ·æ•´ä¸ªé¡µé¢çš„é«˜åº¦ */ overflow: hidden; /* æº¢å‡ºçš„å†…å®¹éšè— */ z-index: 1; /* é«˜äºå®ƒçš„ä¼ªå…ƒç´ é«˜åº¦ */&#125; -&gt; ç°åœ¨å¼€å§‹è®¾å®šèƒŒæ™¯å›¾åŠé«˜æ–¯æ¨¡ç³Šï¼Œç”¨åˆ°äº†ä¼ªå…ƒç´ å”·ï¼ˆâ‰§âˆ‡â‰¦ï¼‰ 12345678910111213.animeDetails_mask::before &#123; content: &quot;&quot;; /* ä¼ªå…ƒç´ ä½¿ç”¨content: &quot;&quot;æŒ‡å®šå†…å®¹ä¸ºç©ºç™½ï¼Œä»¥ä¿æŒè¿™ä¸ªä¼ªå…ƒç´ å¯è§ï¼ˆè¢«æ’‘å¼€äº†ï¼Œä¸ç„¶æ²¡æœ‰å†…å®¹height=0ï¼‰ã€‚ */ position: absolute; /* è®¾å®šå æ»¡ç”»é¢ å¼€å§‹ */ top: -100px; left: -100px; right: -100px; bottom: -100px; /* è®¾å®šå æ»¡ç”»é¢ ç»“æŸ */ background-image: url(&quot;https://www.dmoe.cc/random.php&quot;); /* ç”¨æ¥è®¾å®šèƒŒæ™¯å›¾ï¼Œè¿™ä¸ªurlæ˜¯ä¸€ä¸ªå…è´¹çš„éšæœºäºŒæ¬¡å…ƒå›¾ç‰‡api */ background-repeat: no-repeat; /* è®¾å®šèƒŒæ™¯å›¾ä¸ºä¸é‡å¤ */ background-size: cover; /* è®¾å®šèƒŒæ™¯å›¾çš„å±•ç¤ºæ ·å¼ */ filter: blur(16px); /* è®¾å®šé«˜æ–¯æ¨¡ç³Š16px */ z-index: -1; /* ä»¥å…æŒ¡åˆ°æ–‡æœ¬ */ &#125; !!!ç»ˆäºï¼Œå®Œæˆæƒ¹ï¼Œæ¥çœ‹çœ‹æ•ˆæœå§ å¥½åƒï¼ŒçœŸçš„æœ‰é«˜æ–¯æ¨¡ç³Šäº†ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆå›¾ä¼šä¸é€æ˜åº¦è¿™ä¹ˆä½ï¼Œè®©æˆ‘æ€ä¹ˆçœ‹å­—å•Šï¼ å¯¹æƒ¹ï¼åœ¨ Div.animeDetails_mask ä¸Šè®¾å®šèƒŒæ™¯è‰²å°±å¥½äº†å§ï¼ ä¸ç®¡ç”¨æ¬¸ï¼Œè¿™æ˜¯æ€ä¹ˆå›äº‹å‘¢ï¼Ÿ å…¶å®ç­”æ¡ˆå¾ˆç®€å•ï¼Œ ::before ä½¿ç”¨äº†position: absoluteï¼Œå·²ç»åœ¨æ–‡æ¡£æµæœ€ä¸Šæ–¹äº†ï¼Œä¼šå§åé¢çš„èƒŒæ™¯è‰²é®ä½ã€‚ è§£å†³æ–¹æ¡ˆå°±æ˜¯ï¼Œç”¨ ::after è®¾å®šèƒŒæ™¯è‰² 12345678910.animeDetails_mask::after &#123; content: &quot;&quot;; /* ä¼ªå…ƒç´ ä½¿ç”¨content: &quot;&quot;æŒ‡å®šå†…å®¹ä¸ºç©ºç™½ï¼Œä»¥ä¿æŒè¿™ä¸ªä¼ªå…ƒç´ å¯è§ï¼ˆè¢«æ’‘å¼€äº†ï¼Œä¸ç„¶æ²¡æœ‰å†…å®¹height=0ï¼‰ã€‚ */ position: absolute; /* è®¾å®šå æ»¡ç”»é¢ å¼€å§‹ */ top: -100px; left: -100px; right: -100px; bottom: -100px; /* è®¾å®šå æ»¡ç”»é¢ ç»“æŸ */ background-color: rgba(255, 255, 255, .9); /* è®¾å®šèƒŒæ™¯è‰²ï¼Œæ¥è®©é«˜æ–¯æ¨¡ç³Šèƒ½æœ‰ç™½è‰²çš„åº• */ z-index: -1; /* ä»¥å…æŒ¡åˆ°æ–‡æœ¬ */&#125; -&gt; æˆæœé¢„è§ˆ å¦ä¸€ç§å®ç°æ–¹æ³•ä¸FireFoxä¸ç›¸å®¹ -&gt; ç»™ #animeDetails è®¾å®šèƒŒæ™¯å›¾-&gt; ç»™ .animeDetails_mask è®¾å®šæ ·å¼ 1backdrop-filter: blur(16px); åŒæ ·èƒ½å®Œæˆ"}]