[{"title":"blog多语言计划","path":"2022/10/17/blog多语言计划/","text":"现在我的blog支援两个语言了！ ！ ！ ！ ！目前有两个副本，支援「简体字」与「繁体字」，预计之后会加入「English」，下面会给出跳转连结！ 繁体字简体字"},{"title":"使用Cloudflare Worker来进行Firebase代理","path":"2022/07/19/使用Cloudflare Worker来进行Firebase代理/","text":"使用Cloudflare Worker代理Firebase链接 最近有一个专案使用Firebase来存储用户们上传的图片档，但是Firebase在中国大陆是被防火长城阻挡的，因此中国大陆的使用者无法查看图片 于是，就有了本篇Blog 这篇Blog会教你如何使用Cloudflare提供的免费的Worker服务，来建立一个Proxy，然后无论来自哪个地方的人都可以通过代理的连结正常访问Firebase的档案。 顺带一提： 文章末尾有在下搭建好的代理连结，各位也可以使用在下的Proxy，免去自己搭建的麻烦！ ！ 首先需要一个Cloudflare帐户，如果没有可以去注册一个 -&gt; 0、 Cloudflare官方网站的连结 -&gt; 1、登入后，进入你的控制台 -&gt; 2、选择左边的Worker -&gt; 3、再点选「建立服务」注意这里选择「Http处理常式」即可 -&gt; 4、点选「快速编辑」！我们不使用Cli进行编辑，因为这属于简单的任务，使用Cli反而浪费时间 -&gt; 5、开始编写代理服务！简单介绍一下什么是Cloudflare Worker***Cloudflare Worker其实是Cloudflare提供的一个极其轻量的云端伺服器，它的基本功能就是能够接受请求，进行处理后返回数据&#x2F;网页等等资源。 ******Cloudflare Worker是免费使用的（免费计画），并且大多数情况下，免费计画就已经能够满足我们的大部分需求。 *** -&gt; 6、能够透过Worker访问被封锁的Firebase的原理***上文提到，Firebase在中国大陆被封锁。但是Worker并未被封锁，并且Worker能够正常访问Firebase，因此就可以实现以下逻辑。 ***使用者透过向Worker发起请求（请求）-&gt; Worker接受请求，并读取请求内需要代理访问的地址 -&gt; Worker访问地址得到资源 -&gt; 返回给来源 -&gt; 7、源代码及部分***代码源自网路，对于本专案的需求，在下进行了更改适配。 *** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416addEventListener(&quot;fetch&quot;, event =&gt; &#123; event.passThroughOnException(); if (event.request.method === &#x27;GET&#x27;) &#123; const url = new URL(event.request.url); const accept = event.request.headers.get(&#x27;Accept&#x27;); if (url.pathname.startsWith(&#x27;/firebasestorage.googleapis.com/&#x27;)) &#123; // 將請求轉發給原伺服器 event.respondWith(proxyRequest(&#x27;https:/&#x27; + url.pathname + url.search, event.request)); &#125; else if (accept &amp;&amp; (accept.indexOf(&#x27;text/html&#x27;) &gt;= 0 || accept.indexOf(&#x27;text/css&#x27;) &gt;= 0)) &#123; if (url.pathname.startsWith(&#x27;/firebasestorage.googleapis.com/&#x27;)) &#123; event.respondWith(proxyStylesheet(&#x27;https:/&#x27; + url.pathname + url.search, event.request)); &#125; else &#123; event.respondWith(processRequest(event.request, event)); &#125; &#125; &#125;&#125;);const VALID_CHARSETS = [&#x27;utf-8&#x27;, &#x27;utf8&#x27;, &#x27;iso-8859-1&#x27;, &#x27;us-ascii&#x27;];async function proxyRequest(url, request) &#123; let init = &#123; method: request.method, headers: &#123;&#125; &#125;; // 只允許這些Headers const proxyHeaders = [&quot;Accept&quot;, &quot;Accept-Encoding&quot;, &quot;Accept-Language&quot;, &quot;Referer&quot;, &quot;User-Agent&quot;]; for (let name of proxyHeaders) &#123; let value = request.headers.get(name); if (value) &#123; init.headers[name] = value; &#125; &#125; // 使用源ip新建 X-Forwarded-For 請求頭 const clientAddr = request.headers.get(&#x27;cf-connecting-ip&#x27;); if (clientAddr) &#123; init.headers[&#x27;X-Forwarded-For&#x27;] = clientAddr; &#125; const response = await fetch(url, init); if (response) &#123; const responseHeaders = [&quot;Content-Type&quot;, &quot;Cache-Control&quot;, &quot;Expires&quot;, &quot;Accept-Ranges&quot;, &quot;Date&quot;, &quot;Last-Modified&quot;, &quot;ETag&quot;]; let responseInit = &#123;status: response.status, statusText: response.statusText, headers: &#123;&#125;&#125;; for (let name of responseHeaders) &#123; let value = response.headers.get(name); if (value) &#123; responseInit.headers[name] = value; &#125; &#125; responseInit.headers[&#x27;X-Content-Type-Options&#x27;] = &quot;nosniff&quot;; const newResponse = new Response(response.body, responseInit); return newResponse; &#125; return response;&#125;async function proxyStylesheet(url, request) &#123; let css = await fetchCSS(url, request) if (css) &#123; const responseInit = &#123;headers: &#123; &quot;Content-Type&quot;: &quot;text/css; charset=utf-8&quot;, &quot;Cache-Control&quot;: &quot;private, max-age=86400, stale-while-revalidate=604800&quot; &#125;&#125;; const newResponse = new Response(css, responseInit); return newResponse; &#125; else &#123; return proxyRequest(url, request); &#125;&#125;async function processRequest(request, event) &#123; const response = await fetch(request); if (response &amp;&amp; response.status === 200) &#123; const contentType = response.headers.get(&quot;content-type&quot;); if (contentType &amp;&amp; contentType.indexOf(&quot;text/html&quot;) !== -1) &#123; return await processHtmlResponse(response, event.request, event); &#125; else if (contentType &amp;&amp; contentType.indexOf(&quot;text/css&quot;) !== -1) &#123; return await processStylesheetResponse(response, event.request, event); &#125; &#125; return response;&#125;async function processHtmlResponse(response, request, event) &#123; const contentType = response.headers.get(&quot;content-type&quot;); const charsetRegex = /charset\\s*=\\s*([^\\s;]+)/mgi; const match = charsetRegex.exec(contentType); if (match !== null) &#123; let charset = match[1].toLowerCase(); if (!VALID_CHARSETS.includes(charset)) &#123; return response; &#125; &#125; let embedStylesheet = true; let csp = response.headers.get(&quot;Content-Security-Policy&quot;); if (csp) &#123; let ok = false; let cspRule = null; const styleRegex = /style-src[^;]*/gmi; let match = styleRegex.exec(csp); if (match !== null) &#123; cspRule = match[0]; &#125; else &#123; const defaultRegex = /default-src[^;]*/gmi; let match = defaultRegex.exec(csp); if (match !== null) &#123; cspRule = match[0]; &#125; &#125; if (cspRule !== null) &#123; if (cspRule.indexOf(&quot;&#x27;unsafe-inline&#x27;&quot;) &gt;= 0) &#123; ok = true; embedStylesheet = true; &#125; else if (cspRule.indexOf(&quot;&#x27;self&#x27;&quot;) &gt;= 0) &#123; ok = true; embedStylesheet = false; &#125; &#125; if (!ok) &#123; return response; &#125; &#125; const &#123; readable, writable &#125; = new TransformStream(); const newResponse = new Response(readable, response); modifyHtmlStream(response.body, writable, request, event, embedStylesheet); return newResponse;&#125;async function processStylesheetResponse(response, request, event) &#123; let body = response.body; try &#123; body = await response.text(); const fontCSSRegex = /@import\\s*(url\\s*)?[\\(&#x27;&quot;\\s]+((https?:)?\\/\\/fonts.googleapis.com\\/css[^&#x27;&quot;\\)]+)[\\s&#x27;&quot;\\)]+\\s*;/mgi; let match = fontCSSRegex.exec(body); while (match !== null) &#123; const matchString = match[0]; const fontCSS = await fetchCSS(match[2], request, event); if (fontCSS.length) &#123; body = body.split(matchString).join(fontCSS); fontCSSRegex.lastIndex -= matchString.length - fontCSS.length; &#125; match = fontCSSRegex.exec(body); &#125; &#125; catch (e) &#123;&#125; const newResponse = new Response(body, response); return newResponse;&#125;function chunkContainsInvalidCharset(chunk) &#123; let invalid = false; const charsetRegex = /&lt;\\s*meta[^&gt;]+charset\\s*=\\s*[&#x27;&quot;]([^&#x27;&quot;]*)[&#x27;&quot;][^&gt;]*&gt;/mgi; const charsetMatch = charsetRegex.exec(chunk); if (charsetMatch) &#123; const docCharset = charsetMatch[1].toLowerCase(); if (!VALID_CHARSETS.includes(docCharset)) &#123; invalid = true; &#125; &#125; const contentTypeRegex = /&lt;\\s*meta[^&gt;]+http-equiv\\s*=\\s*[&#x27;&quot;]\\s*content-type[^&gt;]*&gt;/mgi; const contentTypeMatch = contentTypeRegex.exec(chunk); if (contentTypeMatch) &#123; const metaTag = contentTypeMatch[0]; const metaRegex = /charset\\s*=\\s*([^\\s&quot;]*)/mgi; const metaMatch = metaRegex.exec(metaTag); if (metaMatch) &#123; const charset = metaMatch[1].toLowerCase(); if (!VALID_CHARSETS.includes(charset)) &#123; invalid = true; &#125; &#125; &#125; return invalid;&#125;async function modifyHtmlStream(readable, writable, request, event, embedStylesheet) &#123; const reader = readable.getReader(); const writer = writable.getWriter(); const encoder = new TextEncoder(); let decoder = new TextDecoder(&quot;utf-8&quot;, &#123;fatal: true&#125;); let firstChunk = true; let unsupportedCharset = false; let partial = &#x27;&#x27;; let content = &#x27;&#x27;; try &#123; for(;;) &#123; const &#123; done, value &#125; = await reader.read(); if (done) &#123; if (partial.length) &#123; partial = await modifyHtmlChunk(partial, request, event, embedStylesheet); await writer.write(encoder.encode(partial)); partial = &#x27;&#x27;; &#125; break; &#125; let chunk = null; if (unsupportedCharset) &#123; await writer.write(value); continue; &#125; else &#123; try &#123; chunk = decoder.decode(value, &#123;stream:true&#125;); &#125; catch (e) &#123; unsupportedCharset = true; if (partial.length) &#123; await writer.write(encoder.encode(partial)); partial = &#x27;&#x27;; &#125; await writer.write(value); continue; &#125; &#125; try &#123; if (firstChunk) &#123; firstChunk = false; if (chunkContainsInvalidCharset(chunk)) &#123; // switch to passthrough unsupportedCharset = true; if (partial.length) &#123; await writer.write(encoder.encode(partial)); partial = &#x27;&#x27;; &#125; await writer.write(value); continue; &#125; &#125; content = partial + chunk; partial = &#x27;&#x27;; const linkPos = content.lastIndexOf(&#x27;&lt;link&#x27;); if (linkPos &gt;= 0) &#123; const linkClose = content.indexOf(&#x27;/&gt;&#x27;, linkPos); if (linkClose === -1) &#123; partial = content.slice(linkPos); content = content.slice(0, linkPos); &#125; &#125; if (content.length) &#123; content = await modifyHtmlChunk(content, request, event, embedStylesheet); &#125; &#125; catch (e) &#123;&#125; if (content.length) &#123; await writer.write(encoder.encode(content)); content = &#x27;&#x27;; &#125; &#125; &#125; catch(e) &#123;&#125; try &#123; await writer.close(); &#125; catch(e) &#123;&#125;&#125;async function modifyHtmlChunk(content, request, event, embedStylesheet) &#123; const fontCSSRegex = /&lt;link\\s+[^&gt;]*href\\s*=\\s*[&#x27;&quot;]((https?:)?\\/\\/fonts.googleapis.com\\/css[^&#x27;&quot;]+)[^&gt;]*&gt;/mgi; let match = fontCSSRegex.exec(content); while (match !== null) &#123; const matchString = match[0]; if (matchString.indexOf(&#x27;stylesheet&#x27;) &gt;= 0) &#123; if (embedStylesheet) &#123; const fontCSS = await fetchCSS(match[1], request, event); if (fontCSS.length) &#123; // See if there is a media type on the link tag let mediaStr = &#x27;&#x27;; const mediaMatch = matchString.match(/media\\s*=\\s*[&#x27;&quot;][^&#x27;&quot;]*[&#x27;&quot;]/mig); if (mediaMatch) &#123; mediaStr = &#x27; &#x27; + mediaMatch[0]; &#125; // Replace the actual css let cssString = &quot;&lt;style&quot; + mediaStr + &quot;&gt;\\n&quot;; cssString += fontCSS; cssString += &quot;\\n&lt;/style&gt;\\n&quot;; content = content.split(matchString).join(cssString); fontCSSRegex.lastIndex -= matchString.length - cssString.length; &#125; &#125; else &#123; // Rewrite the URL to proxy it through the origin let originalUrl = match[1]; let startPos = originalUrl.indexOf(&#x27;/fonts.googleapis.com&#x27;); let newUrl = originalUrl.substr(startPos); let newString = matchString.split(originalUrl).join(newUrl); content = content.split(matchString).join(newString); fontCSSRegex.lastIndex -= matchString.length - newString.length; &#125; match = fontCSSRegex.exec(content); &#125; &#125; return content;&#125;var FONT_CACHE = &#123;&#125;;async function fetchCSS(url, request) &#123; let fontCSS = &quot;&quot;; if (url.startsWith(&#x27;/&#x27;)) url = &#x27;https:&#x27; + url; const userAgent = request.headers.get(&#x27;user-agent&#x27;); const clientAddr = request.headers.get(&#x27;cf-connecting-ip&#x27;); const browser = getCacheKey(userAgent); const cacheKey = browser ? url + &#x27;&amp;&#x27; + browser : url; const cacheKeyRequest = new Request(cacheKey); let cache = null; let foundInCache = false; if (cacheKey in FONT_CACHE) &#123; // hit in the memory cache fontCSS = FONT_CACHE[cacheKey]; foundInCache = true; &#125; else &#123; // Try pulling it from the cache API (wrap it in case it&#x27;s not implemented) try &#123; cache = caches.default; let response = await cache.match(cacheKeyRequest); if (response) &#123; fontCSS = await response.text(); foundInCache = true; &#125; &#125; catch(e) &#123; // Ignore the exception &#125; &#125; if (!foundInCache) &#123; let headers = &#123;&#x27;Referer&#x27;: request.url&#125;; if (browser) &#123; headers[&#x27;User-Agent&#x27;] = userAgent; &#125; else &#123; headers[&#x27;User-Agent&#x27;] = &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&quot;; &#125; if (clientAddr) &#123; headers[&#x27;X-Forwarded-For&#x27;] = clientAddr; &#125; try &#123; const response = await fetch(url, &#123;headers: headers&#125;); if (response &amp;&amp; response.status === 200) &#123; fontCSS = await response.text(); fontCSS = fontCSS.replace(/(https?:)?\\/\\/fonts\\.gstatic\\.com\\//mgi, &#x27;/fonts.gstatic.com/&#x27;); FONT_CACHE[cacheKey] = fontCSS; try &#123; if (cache) &#123; const cacheResponse = new Response(fontCSS, &#123;ttl: 86400&#125;); event.waitUntil(cache.put(cacheKeyRequest, cacheResponse)); &#125; &#125; catch(e) &#123;&#125; &#125; &#125; catch(e) &#123;&#125; &#125; return fontCSS;&#125;function getCacheKey(userAgent) &#123; let os = &#x27;&#x27;; const osRegex = /^[^(]*\\(\\s*(\\w+)/mgi; let match = osRegex.exec(userAgent); if (match) &#123; os = match[1]; &#125; let mobile = &#x27;&#x27;; if (userAgent.match(/Mobile/mgi)) &#123; mobile = &#x27;Mobile&#x27;; &#125; const edgeRegex = /\\s+Edge\\/(\\d+)/mgi; match = edgeRegex.exec(userAgent); if (match) &#123; return &#x27;Edge&#x27; + match[1] + os + mobile; &#125; const chromeRegex = /\\s+Chrome\\/(\\d+)/mgi; match = chromeRegex.exec(userAgent); if (match) &#123; return &#x27;Chrome&#x27; + match[1] + os + mobile; &#125; const webkitRegex = /\\s+AppleWebKit\\/(\\d+)/mgi; match = webkitRegex.exec(userAgent.match); if (match) &#123; return &#x27;WebKit&#x27; + match[1] + os + mobile; &#125; const firefoxRegex = /\\s+Firefox\\/(\\d+)/mgi; match = firefoxRegex.exec(userAgent); if (match) &#123; return &#x27;Firefox&#x27; + match[1] + os + mobile; &#125; return null;&#125; 现在即可使用，方法是例如我要访问https://firebasestorage.googleapis.com/v0/b/mikuproject-e9478.appspot.com/o/mikuproject-files%2F404.png?alt=media&amp;token=40bb05e9-d925-48a4-b4f5-800a28153b92现在只要在连结的https:&#x2F;&#x2F;后，加上你的Worker的域名即可更改后的连结变为https://objectproxy.1205.moe/firebasestorage.googleapis.com/v0/b/mikuproject-e9478.appspot.com/o/mikuproject-files%2F404.png?alt=media&amp;token=40bb05e9-d925-48a4-b4f5-800a28153b92 现成的作业 Worker: https://objectproxy.1205.moe/"},{"title":"在Vue程式中使用Electron框架","path":"2022/05/01/在Vue程序中使用Electron框架/","text":"在Vue程式中使用Electron框架 今天秃然遇到一个需求，即构建跨平台的应用程式，那么对于我一个全栈开发来说，使用Electron就是最好的选择了。 了解一下，什么是Electron ***Electron 是一个开源 JavaScript 框架，用于使用 Web 技术（HTML、CSS 和 JavaScript）构建跨平台的应用程序。这意味着如果您事先熟悉使用这些技术，您可以直接使用原先的源代码构建成Windows、Linux 和 macOS 的桌面应用程序。 *** ***背后，Electron 将 Chromium 引擎与 Node.js 运行时环境相结合，来运行您的程式。而且，已有许多知名以Electron构建的程式，比如 Slack、VS Code 和 WhatsApp Desktop。 *** 那么，依照与我的本次实践，来告诉各位小猫咪如何使用Electron构建基于Vue的App -&gt; 0、最基本的安装npm（不需要讲了吧www） -&gt; 1、安装vue cli 1npm install -g @vue/cli 全局安装vue cli -&gt; 2、使用vue create指令新建一个项目 1vue create your-project 新建一个名字是your-project的项目 -&gt; 3、使用vue add命令新增一个插件 1vue add electron-builder 将名字是electron-builder的插件加入你的项目!注意，您需要cd入您的项目目录后方可执行这条命令 -&gt; 4、运行程式 1npm run electron:serve 开启应用程式!注意，您需要cd入您的项目目录后方可执行这条命令!注意，若有错误您可以尝试执行 npm i 现在即可进行开发 如何打包成可以分发的应用程式呢？ 其实很简单，在需要打包成对应应用程式的平台内执行： 1npm run electron:build 现在即可完成这个应用的开发！"},{"title":"转义","path":"2022/04/13/转义/","text":"转义 由于学习JavaScript时是依照实际案例来学习的，因此遗漏了某些少用到的方面。 最近在实现一个需求时，发现转义符真的超好用！ ！下面是需求详情： -&gt;需要向伺服器内存入html片段，并且这些html片段有行内样式，如下图 12345&#123; &quot;title&quot;:&quot;SPRING&quot;, &quot;honor&quot;:&quot;&lt;span style=&#x27;color: blue;&#x27;&gt;SPRING&lt;/span&gt;&quot;, &quot;description&quot;:&quot;代表您加入了SPRING计画&quot;&#125; 发现问题🤔：在这里单引号，双引号都用上了，那么要如何才能在SQL语句内拼上这段字符串呢？ 超级重要！ ！ ！ -&gt; SQL语句需要被一对引号括起来。 有的小猫咪可能就会说了，用模板字符串(``)不就可以了吗？ 其实是不行的，请看这张图 这里使用单引号、双引号都会报错 -&gt; 所以这里的解决方案就是：转义符号给出正确的SQL语句 1UPDATE items SET itemValue =&#x27;&#123;&quot;title&quot;:&quot;SPRING&quot;,&quot;honor&quot;:&quot;&lt;span style=\\&#x27;color: blue;\\&#x27;&gt;SPRING&lt;/span&gt;&quot;,&quot;description&quot;:&quot;代表您加入了SPRING计画&quot;&#125;&#x27; WHERE itemKey=&quot;UID1*ActivatedHonor&quot; 成功！"},{"title":"用css实现网页高斯模糊特效","path":"2022/02/21/用css实现网页高斯模糊背景/","text":"用css实现网页高斯模糊特效 Attention: 这篇文章探讨的是如何实现背景高斯模糊，而不是整个视图高斯模糊！ ！ ！ 大概效果是这样： 没有高斯模糊 使用高斯模糊效果 怎么样？ ？是不是感觉好漂亮的效果，那么如何实现呢(¯︶¯) 先来看看DOM结构其实有两种方法，这是方法一，相容性较好！ -&gt; 外层有一个 id&#x3D;animeDetails 的Div标签，用于撑起整个页面的高度123#animeDetails &#123; height: 100%;&#125; -&gt; 内层使用了 class&#x3D;animeDetails_mask 的一个Div标签用于放入要展示的内容，例如现在我放入的是contents这几个字123456.animeDetails_mask &#123; position: relative; /* 让这个div能够占满画面 */ height: 100%; /* 撑起整个页面的高度 */ overflow: hidden; /* 溢出的内容隐藏 */ z-index: 1; /* 高于它的伪元素高度 */&#125; -&gt; 现在开始设定背景图及高斯模糊，用到了伪元素唷（≧∇≦） 12345678910111213.animeDetails_mask::before &#123; content: &quot;&quot;; /* 伪元素使用content: &quot;&quot;指定内容为空白，以保持这个伪元素可见（被撑开了，不然没有内容height=0）。 */ position: absolute; /* 设定占满画面 开始 */ top: -100px; left: -100px; right: -100px; bottom: -100px; /* 设定占满画面 结束 */ background-image: url(&quot;https://www.dmoe.cc/random.php&quot;); /* 用来设定背景图，这个url是一个免费的随机二次元图片api */ background-repeat: no-repeat; /* 设定背景图为不重复 */ background-size: cover; /* 设定背景图的展示样式 */ filter: blur(16px); /* 设定高斯模糊16px */ z-index: -1; /* 以免挡到文本 */ &#125; !!!终于，完成惹，来看看效果吧 好像，真的有高斯模糊了，但是为什么图会不透明度这么低，让我怎么看字啊！ 对惹！在 Div.animeDetails_mask 上设定背景色就好了吧！ 不管用欸，这是怎么回事呢？ 其实答案很简单， ::before 使用了position: absolute，已经在文档流最上方了，会吧后面的背景色遮住。 解决方案就是，用 ::after 设定背景色 12345678910.animeDetails_mask::after &#123; content: &quot;&quot;; /* 伪元素使用content: &quot;&quot;指定内容为空白，以保持这个伪元素可见（被撑开了，不然没有内容height=0）。 */ position: absolute; /* 设定占满画面 开始 */ top: -100px; left: -100px; right: -100px; bottom: -100px; /* 设定占满画面 结束 */ background-color: rgba(255, 255, 255, .9); /* 设定背景色，来让高斯模糊能有白色的底 */ z-index: -1; /* 以免挡到文本 */&#125; -&gt; 成果预览 另一种实现方法与FireFox不相容 -&gt; 给 #animeDetails 设定背景图-&gt; 给 .animeDetails_mask 设定样式 1backdrop-filter: blur(16px); 同样能完成"}]